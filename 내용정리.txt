*******180107
* Chapter 01 템플릿 형식 연역 규칙
	sample) tempalte <typename T>
		void f(ParamType param) ... f(expr);

	case 1 : ParamType이 포인터(T*) 또는 참조 형식(T&)이나 보편참조(universal reference)는 아닌 경우
		포인터나 참조자 속성은 제외한 나머지가 T의 형식으로 추론된다
		ex) expr이 int* 이고 ParamType이 const T*면 -> T는 int로 추론된다.
		ex) expr이 const int이고 ParamType이 T&라면 -> T는 const int이며 ParamType은 const int&가 된다.
	
	case 2 : ParamType이 보편참조(T&&)인 경우
		LValue는 T와 ParamType이 둘 다 T&로, RValue인 경우는 T는 T이고 ParamType은 T&&로 표현된다.
		ex) int x = 3; f(x); 라면 T와 ParamType 둘 다 int&로 연역된다.
		ex) cosnt int& y = x; f(y); 라면 T와 ParamType 둘 다 const int& 이다.
		ex) f(23); 라면 T는 int이고, ParamType은 int&& 이다.
	이유는 후에 보편참조 및 퍼펙트포워딩에서 설명하고, 이와 같이 LValue와 RValue에 대해 다른 연역 규칙이 적용되는건 &&가 유일
	
	case 3 : ParamType이 포인터도 아니고 참조도 아닌 경우 값에 의한 전달, 즉 복사되는 경우
		복사본이 생성된다.참조 그리고 const 게다가 volatile 속성까지 무시된다.
		void f(T param)에서 int x; 건 const int cx;건 const int& rx;건 모두 T와 ParamType 둘 다 int이다.
		허나 expr이 const 객체를 가리키는 const 포인터라면? const char* const x; -> 포인터의 상수성은 빠지고 const char*로 넘어간다.
	
		배열의 경우, 함수 시그니처 자체에서는 int[]는 int*와 같다. 허나 배열에 대한 참조를 통해 배열로 연역할 수 있고 개수도 알 수 있다.
		template<class T, std::size_t N>
		std::size_t f(T(&param)[N]);  int x[] = {3,4,5}; -> N은 3이며 T는 int로, ParamType은 int [3]으로 연역된다.	
		위와 같이 배열이 포인터로 붕괴되는 경우에 더불어, 함수 형식도 함수 포인터로 붕괴된다. void func(void); f(func);면 T는 void (*)(void)
		하지만 배열 참조와 같이 참조로 ParamType이 표현되는 경우 붕괴되지 않는다.


* Chapter 02 auto의 형식 연역 규칙
	특별한 한 경우를 제외하곤 템플릿 형식 연역 규칙과 같다.
	case 1 : 형식 지정자가 포인터나 참조 형식이지만 보편참조는 아닌 경우
	case 2 : 보편 참조인 경우
	case 3 : 형식 지정자가 포인터도 아니고 참조도 아닌 경우
		템플릿과 똑같으나, c++11부터 생긴 {}초기화에 의해 다른 점이 발생한다
		auto x1 = 3;
		auto x2(3);
		auto x3{3};	
		auto x4 = {3};	//이 경우 std::initializer_list의 형식으로 연역된다
	c++14에서, return 형식에 auto 연역을 사용할 수 있으나 이 때에는 템플릿 연역 규칙을 따른다
	즉 auto f() { return {1,2,3}; } 은 컴파일 오류가 발생한다. 템플릿 연역 규칙에서는 형식 연역이 불가능하므로

* Chapter 03 decltype의 작동 방식
	decltype(expr) -> 이름이나 표현식의 형식을 알려준다.
	auto 반환형의 후행 반환 형식 auto f() -> decltype(param)에 사용되는 경우, 반환형의 연역에서 &나 const 속성이 누락될 수 있다
	고로 decltype(auto) f()의 표현으로 정확한 형식을 반환할 수 있다. 물론 변수의 선언에서도 사용 가능
	
	decltype은 형식이 T이고 이름이 아닌 왼값 표현식에 대해서는 항상 T&를 반환한다.
	int x = 3; decltype(x) 는 int이나 decltype((x))는 int&이다. (x)는 이름이 아닌 표현식이다.


* Chapter 04 연역된 형식을 파악하는 방법을 알자 / typeid.name()을 믿지 마라
	template<class Cont>
	void foo(Cont&& c); 와 같은 경우, c에 좌변값이건 우변값이건 typeid(c).name()은 그저 Cont의 타입을 반환할 뿐이다.
	즉 이것이 좌변값 참조인지 우변값 참조인지도 모르고, 심지어 const나 volatile 속성도 파악되지 않는다.
	컴파일러에서 확인해도 같으며, 이를 위해 boost의 type_index를 활용, type_id_with_cvr<T>().pretty_name()을 활용해보자.

*******180108
* Chapter 05 명시적 형식 선언보다는 auto를 선호하라
	1. 초기화 누락 방지		//auto x; 잘못된 행동
	2. 장황한 변수 선언을 피한다.	//typename std::iterator_trait<It>::value_type 대신 auto라면?
	3. 클로저를 직접 담는다.	
	std::function<bool(int, int)> func와 auto func의 차이는 다음과 같다
		a) auto는 이 클로저에 요구되는 만큼의 메모리를 할당하나, 
		   function은 임의의 주어진 서명에 대해 고정되어 있으며, 부족한 경우 동적할당을 진행한다. 즉 느리고 위험할 수 있다.
	4. 형식 단축 문제의 회피
		다른 처리단위 cpu에서의 처리(32bit, 64bit)
		의도하지 않은 형식 불일치로 인한 오버헤드 - map<int, int>일 때 for(pair<int, int>& p : map)에서의 문제발생 해결

* Chapter 06 auto가 원치 않은 형식으로 연역될 때에는 명시적 형식 초기치를 사용하라
	예시로 vector<bool> v에서, v[idx]는 bool&를 반환하는 것이 아닌, vector<bool>::reference에 정의된 value를 반환한다.
	그 value가 bool로의 변환이 존재하여 bool b = v[idx];가 가능한 것이며, 이러한 클래스를 대리자(proxy) 클래스 라고 한다.
	고로, auto b = v[idx]를 진행하면 b의 타입은 bool이 아닌 다른 타입(비트를 담은 자료구조의 한 워드를 가리키는 포인터와 offset이 있는)
	
	이를 해결하기 위해 명시적으로 초기치 관용구를 사용한다.
	auto b = static_cast<bool>(v[dex]); 이는 명시적이고 프로그래머의 의도를 표현하기 좋다
	ex) auto eps = static_cast<double>(GetEpsilon()); 에서, double 정확도까지 필요하지 않다면 cast 자료형을 float로 바꾸면 되는 것이다.

* Chapter 07 객체 생성 시 괄호와 중괄호 () {} 를 구분하라
	중괄호 초기화의 장점? 좁히기 변환(narrow casting) 방지
	성가신 구문 해석(Widget w3(); <- w3변수 초기화가 아닌 함수 선언) 고로 Widget w3{}; <- w3 변수 선언
	
	허나 클래스 생성자에서 만일 Widget(std::initializer_list...)가 있다면, 이 생성자에 적법하다면 다른 생성자들이 '강하게' 무시될 것이다
	고로 생성자가 초기화리스트를 사용한다면 특히 주의하고, vector와 같은 템플릿에서의 사용이 달라는 경우를 정확히 파악하자
	vector<int> v(10, 20)와 vector<int> v{10, 20}의 차이?

* Chapter 08 0과 NULL보다 nullptr를 선호하라
	중복적재 문제를 해결할 수 있다. void foo(int), foo(bool), foo(void*)에서 NULL, 0이 인수로 들어가면 적어도 void*는 불리지 않는다.
	템플릿 내에서 타입 연역에서 NULL이나 0은 정수로 처리되는 반면, nullptr는 std::nullptr_t로 적절한 포인터 타입으로 연역될 수 있다.

* Chapter 09 typedef보다 별칭 선언을 선호하라.
	우선, 둘은 형식에 별명을 붙이는 동일한 역할을 한다. 허나 별칭이 좀 더 보기 편할 수 있다.
	typedef void (*FP)(int, int); / using FP = void (*)(int, int);

	사실 더욱이 중요한 것은, typedef는 템플릿화 할 수 없지만 using은 가능하다. 템플릿화된 별칭을 alias templates라 한다.
	typedef도 가능은 하다. c++11이전 프로그램들은 이로 구현되었으니까.
	template<typename T>					template <typename T>
	using MyAllocList = std::list<T, MyAlloc<T>>; 	-->	struct MyAllocList { typedef std::list<T, MyAlloc<T>> type; }
	대신 typedef는 실제 사용하려면 typename을 표기하고, ::type으로 접근해야한다. 의존적 형식이기 때문이다.
	MyAllocList list;	-->	typename MyAllocList<T>::type list; 

	의존적 형식이 발생하는 예시 - 클래스 내에 멤버로써 이름 'type'이 존재한다면?
	ClassName::type의 접근이 typedef의 형태로 타입을 가리키는지 변수를 표현한지 정확히 하기 위해 typename이 필요할 수 밖에;
	type_traits에서 std::remove_const<T>::type과 같은 형식변환 도구들은 c++14에서 using을 사용하여 구현되어있다. std::remove_const_t<T>

* Chapter 10 범위 없는 enum보다 범위 있는 enum을 선호하라
	enum class는 이름 중복으로 인한 문제점이 해결되고, 암묵적 변환 허용하지 않음
	enum class는 전방선언이 가능하여 이로 인해 컴파일 의존성을 피할 수 있다.
	범위없는 기존 enum도 바탕 형식 지정을 통해 전방선언이 가능하긴 한다. enum Type: std::uint32_t; enum class도 바탕 형식 지정 가능
	
* Chapter 11 정의되지 않은 비공개 함수보다 삭제된 함수를 선호하라
	방지하고자 하는 생성자를 private 공간에 두고 구현하지 않는다면 이에 대한 잘못된 접근은 링크 타임에 확인되나
	delete를 사용한 경우 컴파일타임에 확인 가능하다.

	또한 delete 키워드는 단순히 클래스의 멤버 함수 뿐만 아니라 의도치않은 함수 오버로딩의 해결에도 사용될 수 있다.
	ex) bool isLucky(int); isLucky(char) = delete; isLucky(bool) = delete;

	더불어 클래스 내의 템플릿 함수의 삭제를 표현하기 위해 private를 활용할 수 없기에,
	private:
		template<>				//이는 정의오류이다.
		void SomeFunc<SomeClass>(void*);	//템플릿 특수화는 클래스 범위가 아니라 이름공간 범위에서 정의되야 한다.
	public에 정의하고, 클래스 외부에서 delete를 진행할 수 있다.

* Chapter 12 재정의 함수들을 override로 선언하라
	재정의 함수는 다음과 같은 조건을 만족해야 한다
	1. 기반 클래스 함수가 가상 함수여야 하며
	2. 소멸자를 빼곤, 기반함수와 파생함수의 시그니처가 동일해야 한다 예외 명세까지 더불어서
	3. 추가적으로, c++11에선 기반함수와 파생함수의 참조 한정사 역시 같아야 한다.
		참조한정사? 멤버함수 void Do() &; void Do() &&; // <- *this의 왼값 오른값 차이에 의해 다른 호출이 되는 것
	
	만일 이러한 조건을 만족하지 않았음에도 컴파일이 진행되었다면 의도하지 않은 동작이 발생할 수 있다.
	이를 해결하기 위해 파생클래스의 마지막에 ovveride 키워드를 표기, 컴파일러가 잘못된 점 지적한다. ex) void Do() & override;
	
* Chapter 13 iterator보다 const_iterator를 더 선호하라
	const의 의미론을 반복자에 적용할 수 있으니까.

* Chapter 14 예외를 방출하지 않을 함수를 noexcept로 선언하라
	함수가 예외를 던지지 않을 상황을 정확히 파악할 때에 사용하므로, 인터페이스 명세를 분명히한다.
	noexcept 키워드를 통해 더 나은 목적코드를 생성할 수 잇도록 한다.

	특히 이동 연산이나 swap, 메모리 해제 및 소멸자에 적용되며 효율적으로 작동한다.
	noexcept를 선언한다는 것은 컴파일러가 만드는 코드에서 스택 풀기를 위한 내용이나 함수 내 객체 파괴의 순서 들의 정보들이
	필요가 없음을 선언하는 것
	예외 명세가 된 함수에서 예외 발생시 throw()는 스택이 unwind되고 추가적인 동작이 진행된 후 terminate되지만
	noexcept는 스택이 풀릴수도 있고 풀리지 않을 수도 있다. 바로 terminate된다. 함수 내 catch문이 있어도 거기까지 안간다.

	넓은 계약(wide contract)와 좁은 계약의 함수로 인터페이스를 구분할 수 있는데, 
	넓은 계약은 프로그램의 상태와는 무관히 호출할 수 있으며 전달된 인수들에 그 어떤 제약도 가하지 않는다. 즉 미정의 행동이 발생치 않는다.
	좁은 계약은 만일 인수 string이 32자 이하여야 하는 경우, 이는 호출자의 전제조건이므로 함수 자체가 noexcept일 수 있다.
	허나 구현자가 이를 처리하겠다 하면 noexcept를 활용하긴 어려울 것이다.
	
	어떤 함수를 noexcept로 선언하고, 그 함수 내에서 noexcept가 아닌 함수를 호출하더라도 컴파일러는 이를 경고하지 않는다.
	이유는 만일 그 함수 내에서 호출하는 함수들이 noexcept로 선언되지 않은 옛 c std 라이브러리 함수들인 경우

* Chapter 15 가능하면 항상 constexpr을 사용하라
	충격) constexpr의 결과가 반드시 const는 아닐 수 있으며 더불어 반드시 컴파일 시점에 알려진다는 보장이 없다!
	constexpr 객체는 실제로 const 속성이 존재한다
	constexpr 함수는 인수 역시 컴파일 시점에 알려진 값이라면 함수의 결과를 컴파일 도중에 알릴 수 있다,
	 ex) constexpr int SomeFunc(...)는 반환값이 컴파일 타임에 상수로 사용할 수 있음이지 그 값이 const임을 표현하는 것은 아니다. 
	또한 constexpr 함수는 따로 오버로딩 할 필요가 없다. 이 함수가 실행시점에 처리된다면 constexpr 속성이 없는 일반함수로 취급된다.

	c++11까지는 constexpr함수의 return 문은 많아야 하나만이 가능했다. 그래서 조금 복잡한 연산을 위해
	삼항연산자나, 재귀함수를 호출해서 처리하는 경우가 많았다. c++14부터는 조건문 사용도 가능하다.
		
	constexpr 함수는 리터럴 형식을 받고, 돌려주어야 한다. 여기서 말하는 리터럴 형식은 컴파일 도중 값을 결정할 수 있는,
	예를 들면 내장 형식들 그리고 생성자와 적절한 멤버함수들이 constexpr로 선언된 클래스들을 말한다.
	
	c++11에서는 constexpr 멤버함수는 암묵적으로 const함수이나 14에서는 그 제한이 없어졌다. 또한 void는 리터럴 형식이 아니므로
	반환이 불가능했으나 이 역시 14에서 제한이 없어졌다.

* Chapter 16  const 멤버 함수를 스레드 안전하게 작성하라
	만일 const 멤버함수가 단순히 값을 읽는, 즉 read only 동작이라면 상관 없겠지만
	mutable 멤버변수를 관리하게 된다면, 락이 필요할것이다.

* Chapter 17 특수 멤버 함수들의 자동 작성 조건을 숙지하라
	c++98에서 자동으로 만들어 주었던 멤버함수들 - 기본생성자, 소멸자, 복사생성자, 복사대입연산자
	이들은 클라이언트 코드에서 호출이 있을 시에만 생성되며 암묵적으로 public이고 inline이며 가상소멸자인 경우 제외하고 non-virtual이다.
	이제 c++11에서 이동 생성자와 이동 대입 연산자가 추가된 것이다.
	
	차이점이 있는데 복사 생성자와 복사대입연산자는 어느 한 쪽이 선언되었다면, 선언하지 않더라도 다른 한 쪽이 자동으로 작성되나
	이동 생성자와 이동대입연산자는 자동으로 작성되지 않는다. 또한 이동 생성 또는 대입이 작성되면 복사 관련 함수는 자동 작성 안된다.
	이유는 대체로 이에 해당한다 : 프로그래머가 직접 작성했다면 이유가 있으며 그에 맞춰 자동으로 작성된 함수들이 유효하지 않을 수 있으니까
	
	이동연산은 다음의 세 조건이 모두 만족되고, 해당 연산을 호출하는 경우에 자동 작성된다.
	1. 그 어떤 복사 연산이 없고 2. 그 어떤 이동 연산도 없고 3. 소멸자 선언이 되어있지 않은 경우
	이러한 특수 멤버 함수들을 자동 작성 코드로 진행하고자 한다면, = default; 를 이용해보자.

	특이한 경우로, 특수 멤버 함수가 템플릿 함수라면, 이는 자동 작성을 막는 역할을 진행하지는 않는다.
	즉 복사생성자를 템플릿 함수로 작성했다면, 복사생성자 작성에 의해 자동 작성되지 않는 기본 생성자가 작성이 안되는 것이 아니다.

	




 
















